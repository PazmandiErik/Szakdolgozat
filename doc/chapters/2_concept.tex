\Chapter{Koncepció}

\Section{Alpha-algoritmus} 

Az Alpha algoritmus (vagy Alpha bányász) mint folyamatelemzési algoritmus célja, hogy eseménysorozatok halmazából egy ok-okozat rendszert építsen fel. Először van der Aalst, Weijters és Măruşter hozta be a köztudatba. A működésében az eseménysorok halmazát nevezhetjük eseménynaplónak is. Ez az eseménynapló úgynevezett trace hal\hyp{}mazoknak a halmaza, egy trace pedig adott tevékenységnek a sorozata.

Az Alpha bányász volt a legelső folyamatbányászati módszer amit valaha javasoltak és egy egész jó rálátást biztosít a folyamatbányászat céljára, valamint arra, hogy a folyamatokban lévő különböző tevékenységek hogyan is vannak végrehajtva. Emelett, az Alpha bányász szolgált számos újabb folyamatbányászati technika (pl.: Heurisztikus bányász, genetikus bányászat) alapjaként.
	
\begin{definition}{\textit{(Munkafolyamati trace)}} Egy string a $T$ ábécé feladatai közül.\end{definition}
\begin{definition}{\textit{(Munkafolyamati napló)}} Munkafolyamati tracek halmaza.\end{definition}

\subsection{Rövid leírása}	

Az algoritmus egy munkafolyamati naplót $W \subseteq  T^*$ kap bemenetként, és eredményként egy munkafolyamati hálót épít fel.

Ezt az alapján csinálja meg, hogy megvizsgálja az általános kapcsolatokat az egyes feladatok között. Például egy adott feladat lehet, hogy minden esetben megelőz egy másik feladatot, ami egy hasznos információ.

\subsection{Eseménynapló}
Az eseménynapló az elsődleges szükséglet bármely folyamatbányászati algoritmus alkal\hyp{}mazásához. Az eseménynapló a következőket tartalmazza: egyedi azonosító az esethez, tevékenység megnevezése valamint egy időbélyeg. Egy eseménynaplót akár tevékenysé\hyp{}gek halmazának halmazaként is lehet ábrázolni.

Az Alpha bányász szabályai szerint az egyes tevékenységek között az alábbi 4 féle kapcsolat egyike lehetséges:
\begin{enumerate}
\item \textbf{Közvetlen sorrend: $x > y$} akkor és csakis akkor ha az $x$ eseményt közvetlenül követi $y$.
\item \textbf{Okozat: $x \rightarrow y$} ha $x > y$ és nem $y > x$.
\item \textbf{Párhuzam: $x \parallel y$} ha $x > y$ és $y > x$.
\item \textbf{Választás: $x \# y$} ha nem $(x > y)$ és nem $(y > x)$.
\end{enumerate}

\subsection{Minták}

\begin{figure}[h!]
\begin{center}
\caption{\textbf{Szekvencia: A $\rightarrow$ B}}
\includegraphics[width=8truecm, height=4truecm]{images/img_alpha_seq}\\
\label{fig:example}
\end{center}
\end{figure}

\begin{figure}[h!]
\begin{center}
\caption{\textbf{XOR-elágazás: A $\rightarrow$ B, A $\rightarrow$ C} és \textbf{B \# C}}
\includegraphics[width=8truecm, height=6truecm]{images/img_alpha_xor}\\
\label{fig:example}
\end{center}
\end{figure}

\begin{figure}[h!]
\begin{center}
\caption{\textbf{ÉS-elágazás: A $\rightarrow$ B, A $\rightarrow$ C} és \textbf{B $\parallel$ C}}
\includegraphics[width=8truecm, height=6truecm]{images/img_alpha_and}\\
\label{fig:example}
\end{center}
\end{figure}

\newpage

\subsection{Példa}
Vegyük példának a következő eseménynaplót:\\
\begin{figure}[h]
\begin{center}
\caption{Példa eseménynaplpó}
\begin{tabular}{||c | c | c ||}
	\hline
	ID & Tevékenység & Időbélyeg \\ [0.5ex]
	\hline\hline
	1 & A & 2022-10-05 13:50:40.000 \\
	\hline
	1 & B & 2022-10-05 16:30:12.000 \\
	\hline
	1 & C & 2022-10-05 16:57:31.000 \\
	\hline
	1 & D & 2022-10-06 13:50:41.000 \\
	\hline
	2 & A & 2022-10-06 15:30:27.000 \\
	\hline
	2 & C & 2022-10-06 16:23:33.000 \\
	\hline
	2 & B & 2022-10-07 08:33:02.000 \\
	\hline
	2 & D & 2022-10-07 12:41:11.000 \\
	\hline
	3 & A & 2022-10-07 13:02:57.000 \\
	\hline
	3 & E & 2022-10-07 14:11:21.000 \\
	\hline
	3 & D & 2022-10-07 14:59:22.000 \\
	\hline
\end{tabular}
\label{fig:example}
\end{center}
\end{figure}\\	
Ebben az esetben az eseménynaplót az alábbi módon tudjuk jelölni:
\[ 
	L_1 = [< A,B,C,D >, <A,C,B,D>, <A,E,D>]
\]

Az Alpha bányász úgy kezdi a munkát, hogy az eseménynaplót közvetlen-sorrend, okozat, párhuzam és választás relációkra alakítja és ezeket felhasználva létrehoz egy petri hálót ami leírja a folyamat modellét.

Első lépésként létrehoz egy lenyomati mátrixot:

\begin{figure}[h!]
\begin{center}
\caption{Példa lenyomati mátrix}
\begin{tabular}{|c | c | c | c | c | c|}
	\hline
	\hspace{0.1cm} & A & B & C & D & E \\
	\hline
	A & \# & $\rightarrow$ & $\rightarrow$ & \# & $\rightarrow$ \\
	\hline
	B & $\leftarrow$ & \# & $\parallel$ & $\rightarrow$ & \# \\
	\hline
	C & $\leftarrow$ & $\parallel$ & \# & $\rightarrow$ & \# \\
	\hline
	D  & \# & $\leftarrow$ & $\leftarrow$ & \# & $\leftarrow$ \\
	\hline
	E & $\leftarrow$ & \# & \# & $\rightarrow$ & \# \\
	\hline
\end{tabular}
\label{fig:example}
\end{center}
\end{figure}

\newpage

\noindent $Y_W$ az összes $(A,B)$  pár halmaza a feladatok maximális halmazából úgy, hogy:
\begin{itemize}
	\item {Egyik $A \times A$ és $B \times B$ sem tagja $>$-nek, és}
	\item {$A \times B$ részhalmaza $\rightarrow$-nek.}
\end{itemize}
\noindent $P_W$ tartalmazza az egyes $Y_W$-hez tartozó helyeket $p_{(A,B)}$, plussz a beviteli $i_W$ helyet és a kimeneti $o_W$ helyet.
\noindent A folyamati reláció $F_W$ az alábbiak uniójából áll össze:
\begin{itemize}
\item $\{(a,p_{(C,B)})|(A,B) \in Y_W \wedge a \in A\}$
\item $\{(p_{(A,B)},b)|(A,B) \in Y_W \wedge b \in B\}$
\item $\{(i_W,t)|t \in T_1\}$
\item $\{(t,i_0)|t \in T_0\}$
\end{itemize}

\noindent Az eredmény

\begin{itemize}
\item egy Petri háló struktúra $\alpha (W) = (P_W, T_W, F_W)$
\item egy beviteli hellyel $i_W$ és egy kimeneti hellyel $o_W$
\item mivel minden $T_W$ átmenet $F_W$-úton van $i_W$-ből $o_W$-be, így valóban egy munka\hyp{}folyamati háló.
\end{itemize}

\noindent Ehhez a példához az alábbi petri háló jön létre az Alpha bányász használatával
\begin{figure}[h]
\caption{Példa kimeneti petri háló}
\begin{center}
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/img_alpha_petri_output}\\
\label{fig:example}
\end{center}
\end{figure}

\newpage

\subsection{Korlátozások}
\begin{itemize}
\item \textbf{Implicit helyek}: Az Alpha bányász nem tud különbséget tenni az implicit és a szükséges helyek között, így a felfedezett petri hálóban előfordulhatnak plusz szükségetelen helyek.
\item \textbf{Ciklusok}: Az Alpha bányász nem képes 1-gyes és 2-tes hosszúságú ciklusok felismerésére a folyamatmodellben.
\item A helyi függőségeket gyakran nem veszi észre az Alpha bányász.
\end{itemize}

\textit{Forrás: \cite{wiki:001}}

\Section{Robotic Process Automation} 

A Robotikus Folyamatautomatizálás (továbbiakban: RPA) egy olyan szoftvertechnoló\hyp{}gia, mely lehetővé teszi, hogy az erre specializált szoftverek emberi felhasználót emulál\hyp{}va lépjenek kapcsolatba a számítógépek digitális felületeivel.

Minden egyes ilyen szoftvernek más az eszköztára, van amelyik azt tudja értelmezni, hogy mi van a képernyőn, van amelyik felismer és kinyer adatokat, viszont abban mindegyik osztozik, hogy adott lépésekből meghatározott folyamatokat hajt végre.

Összefoglalva, egy ilyen tökéletesített rendszer ugyanazt tudja mint egy felhasználó, viszont sokkal gyorsabban és konzisztensebben, anélkül, hogy fel kellene állnia nyújtózni vagy elmenni egy kávészünetre.

\subsection{Alkalmazási területek}

Lényegében bármely olyan modern cég tudja hasznosítani ezt a technológiát, mely számítógépet használva pl. nyilvántartást vezet, pénzügyeit digitálisan kezeli, alapvető\hyp{}en a digitális térben mozog, stb..., tehát bárhol ahol embereket digitális tevékenységül alul fel lehet szabadítani.

Elsősorban az adott cégtől függ, hogy belevág-e egy ilyen szoftvertechnológiás meg\hyp{}oldásba, de íme néhány szektor ahol alkalmazható, vagy már alkalmazásra is került:
\begin{itemize}
	\item Egészségügy
	\item Telekommunikáció
	\item Gyártástechnológia
	\item Állami szektor
	\item Kereskedelem
	\item Pénzügyi szolgáltatások
\end{itemize}

Gyakorlatilag csupán az adott folyamattól függ, hogy lebontható-e olyan triviális lépésekre, melyeket már az RPA eszközkészletével automatizálni lehet. Természetesen ahogy fejlődik ez a technológia, úgy egyre nagyobb százalékban lehet majd ezeket is automatizáltnak tekinteni.

Alább található néhány mai rendszer, melyeket a technológia úttörőjének lehet nevezni:
\begin{enumerate}
	\item UIPath
	\item Microsoft Power Automate
	\item Blue Prism
	\item Automaton Anywhere
	\item Kofax
\end{enumerate}

\subsection{A technológia jövője}

Mivel egy automatizációs technológia jövőjéről van szó, ezért az RPA nem egy kis dolog ami feltehetően el fog tűnni, hanem nagy valószínűséggel befolyásolni fogja a munkaerőpiac jövőjének egészét...... (folytatni / elvetni?)

\Section{Delphi}

A dolgozathoz készült szoftver Delphi nyelven íródott, így fontos legalább nagyvona\hyp{}lakban ismerni a nyelvet, hogy tudjuk miért is.

A Delphi egy általános célú erősen típusos objektum orientált programozási nyelv és szoftvertermék ami az Object Pascal programozási nyelv Delphi dialektusát használja, integrált fejlesztői környezetet biztosít, újabban a gyors alkalmazásfejlesztés (RAD, Rapid application development) szoftverfejlesztési elv szerint. A Delphi compilerei natív kódot generálnak a célrendszertől függően, legyen az Microsoft Windows, macOS, iOS, Android vagy Linux (x64).

\textit{\cite{delphi:001}}

\subsection{Múltja röviden}
Az ,,anyanyelve" a Delphinek a Pascal, ami pedig a modellje nagy részét az Algolnak köszönheti - az első magas-szintű progamozási nyelvnek ami olvasható, struktúrált és szisztematikusan meghatározott szintaxissal rendelkezik. A hatvanas években számos utódját fejlesztették az Algolnak, ezek közül a legsikeresebb a Pascal volt.

1983-ban jelent meg az első Turbo Pascal a Borland jóvoltából, ami már integrált fejlesztői környezettel rendelkezett. 1995-ben vezették be a RAD szoftverfejlesztési elvre épülülő környezetet, amit Delphi-nek neveztek, ezáltal átalakítva a Pascal nyelvet egy objektum-orientált vizuális programozási nyelvvé. A célja ennek elsősorban az volt, hogy ennek az új terméknek központi részét képezzék az adatbázis eszközök és kapcsolatok.

2006-ban a Borland átadta a fejlesztőeszközöket a CodeGear nevű leányvállalatá\hyp{}nak, majd ezt a leáanyvállalatot 2008-ban eladta az Embarcadero Technologies-nek. Ez az új cég megtartotta a régi fejlesztői divíziót és számos új verziót dobott piacra. 2015-ben az Idera Software nevű cég pedig felvásárolta az Embarcadero-t és mind a mai napig ugyanúgy Embaracadero márka alatt működteti a fejlesztői eszközök divízióját.

Az évek alatt rendkívül sok modernizáción ment át a Delphi. OLE automatizáció és változó adattípus támogatásától kezdve, DLL debugoláson és XML támogatáson keresztül egészen a multi-platform alkalmazásokig és az in-line változó deklarálásig.

\textit{\cite{delphi:002}}

\subsection{Napjainkban}

Sajnos számos rosszul időzített és rosszul kivitelezett marketing döntés miatt a 2000-es évektől kezdve a Delphi kifejezetten kiesett rengeteg programozó kedvelt programozási nyelve közül, azonban az elmúlt néhány évben ismét sikerült egyre nagyobb ismerettség\hyp{}re szert tennie a komolyabb fejlesztők körében.

Bár közel sem a legelterjedtebb nyelv, számos előnnyel rendelkezik sok másikkal szemben. Ilyenek például az alábbiak:
\begin{enumerate}
	\item \textbf{Könnyen olvasható kód}: Már eredetileg a Pascal megalkotásánál az egyik fő cél az volt, hogy oktatási célra lehessen használni, emberi szemmel is könnyen olvasható legyen a komplex alacsony-szintű kód. Erre egy nagyon jó példa a "\{" és "\}" karakterek (amiket csak a memóriával való spórolás miatt jelöltek így) "begin" és "end" kulcsszóra való cseréje.
	\item \textbf{Multi-platformitás}: A megfelelően megírt (OS-független) kódot néhány kattin\hyp{}tással le lehet fordítani a legismertebb operációs rendszerek natív kódjára.
	\item \textbf{Natív kód}: Az alkalmazás lefordításával natív kódot kapunk, ami azért előny, mert semmilyen egyéb keretrendszer telepítésére nincsen szükségem (pl.: MS C++ Runtime Environment, Java Runtime Environment, stb...)
	\item \textbf{Adatbázis támogatás}: Számos adatbázis kapcsolatot és adatfeldolgozási mód\hyp{}szert beépített módon támogat.
	\item \textbf{Fordítási sebesség}: A mai napig az egyik leggyorsabb a fordítási sebessége más fejlesztőeszközökhöz képest, ezáltal felgyorsíva magát a fejlesztési és debugolási folyamatokat.
\end{enumerate}

\subsection{Delphi a dolgozathoz}

Az előző alfejezetben felsoroltaknak megfelelően kiderült, hogy a Delphi az egy kifeje\hyp{}zetten robosztus és erőteljes programozási nyelv. Ez sok nyelvről elmondható természe\hyp{}tesen, viszont az alábbi két pont miatt került kiválasztásra a dolgozathoz:

\begin{itemize}
	\item \textbf{Modern Windows API}: A fejlesztett szoftver (mint a legtöbb RPA eszköz) közvetlen viszonyban van a Windows API-val, hiszen az operációs rendszer teszi elérhetővé az egyes erőforrásokat (pl. rögzíteni a felhasználó bevitelét még akkor is ha a program háttérben van), illetve teszi lehetővé az input injektálását a folyamat visszajátszásához.
	\item \textbf{Natív kód}: Mivel natív kódra kerül fordításra a programkód, ezért bármely Windows (Vista vagy újabb) operációs rendszerrel rendelkező számítógépen fut\hyp{}tatható a program bármiféle keretrendszer nélkül.
\end{itemize}














